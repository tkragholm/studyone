par-reader on  main [!⇡] is 📦 v0.1.0 via 🦀 v1.86.0
❯ cargo expand --example id_field_test
warning: unused variable: `has_record_number`
   --> macros/src/lib.rs:207:9
    |
207 |     let has_record_number = has_field_named(fields, "record_number");
    |         ^^^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_has_record_number`
    |
    = note: `#[warn(unused_variables)]` on by default
    Checking par-reader v0.1.0 (/Users/tobiaskragholm/par-reader)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.01s

#![feature(prelude_import)]
//! Test for different ID field types in registry deserializers
//!
//! This example demonstrates the new support for different ID field types
//! in registry deserializers, including:
//! - PNR (Personal Identification Number) - Default
//! - RECNUM (Record Number) - Used in LPR_DIAG
#[prelude_import]
use std::prelude::rust_2024::*;
#[macro_use]
extern crate std;
use arrow::record_batch::RecordBatch;
use chrono::NaiveDate;
use par_reader::*;
use std::collections::HashMap;
use std::path::Path;
/// Registry using PNR as ID field (default)
#[registry(name = "BEF", description = "Population registry", id_field = "pnr")]
pub struct BefRegistry {
    #[field(name = "PNR")]
    pub pnr: String,
    #[field(name = "FOED_DAG")]
    pub birth_date: Option<NaiveDate>,
    #[field(name = "KOEN")]
    pub gender: Option<String>,
}
/// Auto-generated deserializer for registry
///
/// This deserializer was generated by the RegistryTrait derive macro
/// and provides methods to deserialize Arrow record batches into Individual models.
pub struct BefRegistryDeserializer {
    inner: std::sync::Arc<dyn crate::registry::trait_deserializer::RegistryDeserializer>,
}
#[automatically_derived]
impl ::core::fmt::Debug for BefRegistryDeserializer {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field1_finish(
            f,
            "BefRegistryDeserializer",
            "inner",
            &&self.inner,
        )
    }
}
impl crate::registry::trait_deserializer::RegistryType for BefRegistry {}
impl BefRegistryDeserializer {
    /// Create a new deserializer for registry
    #[must_use]
    pub fn new() -> Self {
        let schema = Self::create_schema();
        let inner = std::sync::Arc::new(
            crate::registry::trait_deserializer_impl::RegistryDeserializerImpl::new(
                "BEF",
                "Population registry",
                schema,
                Some("pnr"),
            ),
        );
        Self { inner }
    }
    /// Create the schema definition for this registry
    fn create_schema() -> crate::schema::RegistrySchema {
        let field_mappings = <[_]>::into_vec(
            ::alloc::boxed::box_new([
                crate::schema::field_def::FieldMapping::new(
                    crate::schema::field_def::FieldDefinition::new(
                        "PNR",
                        "pnr",
                        crate::schema::field_def::FieldType::String,
                        false,
                    ),
                    crate::schema::field_def::mapping::Extractors::string("PNR"),
                    crate::schema::field_def::mapping::ModelSetters::string_setter(|
                        individual,
                        value|
                    {
                        let individual_obj = individual
                            as &mut crate::models::core::Individual;
                        individual_obj.pnr = value;
                    }),
                ),
                crate::schema::field_def::FieldMapping::new(
                    crate::schema::field_def::FieldDefinition::new(
                        "FOED_DAG",
                        "birth_date",
                        crate::schema::field_def::FieldType::Date,
                        true,
                    ),
                    crate::schema::field_def::mapping::Extractors::date("FOED_DAG"),
                    crate::schema::field_def::mapping::ModelSetters::date_setter(|
                        individual,
                        value|
                    {
                        static mut SETTER_COUNT: usize = 0;
                        unsafe {
                            if SETTER_COUNT < 5 {
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "Setting Optional {0} value to Individual: field={1}, value={2:?}\n",
                                            "birth_date",
                                            "birth_date",
                                            value,
                                        ),
                                    );
                                };
                                SETTER_COUNT += 1;
                            }
                        }
                        let individual_obj = individual
                            as &mut crate::models::core::Individual;
                        let boxed_value: Box<dyn std::any::Any + Send + Sync> = Box::new(
                            Some(value),
                        );
                        individual_obj.set_property("birth_date", boxed_value);
                    }),
                ),
                crate::schema::field_def::FieldMapping::new(
                    crate::schema::field_def::FieldDefinition::new(
                        "KOEN",
                        "gender",
                        crate::schema::field_def::FieldType::String,
                        true,
                    ),
                    crate::schema::field_def::mapping::Extractors::string("KOEN"),
                    crate::schema::field_def::mapping::ModelSetters::string_setter(|
                        individual,
                        value|
                    {
                        static mut SETTER_COUNT: usize = 0;
                        unsafe {
                            if SETTER_COUNT < 5 {
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "Setting Optional {0} value to Individual: field={1}, value={2:?}\n",
                                            "gender",
                                            "gender",
                                            value,
                                        ),
                                    );
                                };
                                SETTER_COUNT += 1;
                            }
                        }
                        let individual_obj = individual
                            as &mut crate::models::core::Individual;
                        let boxed_value: Box<dyn std::any::Any + Send + Sync> = Box::new(
                            Some(value),
                        );
                        individual_obj.set_property("gender", boxed_value);
                    }),
                ),
            ]),
        );
        crate::schema::create_registry_schema(
            "BEF",
            "Population registry",
            field_mappings,
        )
    }
    /// Deserialize a record batch using this deserializer
    pub fn deserialize_batch(
        &self,
        batch: &arrow::record_batch::RecordBatch,
    ) -> crate::error::Result<Vec<BefRegistry>> {
        let result = self
            .inner
            .deserialize_batch(batch)?
            .into_iter()
            .map(|individual| BefRegistry::from(individual))
            .collect();
        Ok(result)
    }
    /// Deserialize a single row from a record batch using this deserializer
    pub fn deserialize_row(
        &self,
        batch: &arrow::record_batch::RecordBatch,
        row: usize,
    ) -> crate::error::Result<Option<BefRegistry>> {
        let result = self
            .inner
            .deserialize_row(batch, row)?
            .map(|individual| BefRegistry::from(individual));
        Ok(result)
    }
}
impl From<crate::models::core::Individual> for BefRegistry {
    fn from(individual: crate::models::core::Individual) -> Self {
        static mut PRINT_COUNT: usize = 0;
        unsafe {
            if PRINT_COUNT < 3 {
                {
                    ::std::io::_print(
                        format_args!("Converting Individual to {0}\n", "BefRegistry"),
                    );
                };
                PRINT_COUNT += 1;
            }
        }
        let mut instance = Self::default();
        instance.pnr = individual.pnr.clone();
        if let Some(props) = individual.properties() {
            if let Some(value) = props.get("birth_date") {
                if let Some(date_val) = value.downcast_ref::<Option<chrono::NaiveDate>>()
                {
                    instance.birth_date = *date_val;
                }
            }
        }
        if let Some(props) = individual.properties() {
            if let Some(value) = props.get("gender") {
                if let Some(string_val) = value.downcast_ref::<Option<String>>() {
                    instance.gender = string_val.clone();
                }
            }
        }
        instance
    }
}
impl Default for BefRegistry {
    fn default() -> Self {
        Self {
            pnr: Default::default(),
            birth_date: Default::default(),
            gender: Default::default(),
        }
    }
}
impl Default for BefRegistryDeserializer {
    fn default() -> Self {
        Self::new()
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for BefRegistry {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "BefRegistry",
            "pnr",
            &self.pnr,
            "birth_date",
            &self.birth_date,
            "gender",
            &&self.gender,
        )
    }
}
/// Registry using RECNUM as ID field
#[registry(name = "LPR_ADM", description = "LPR Admission registry", id_field = "pnr")]
pub struct LprAdmRegistry {
    #[field(name = "PNR")]
    pub pnr: String,
    #[field(name = "RECNUM")]
    pub record_number: Option<String>,
    #[field(name = "D_INDDTO")]
    pub admission_date: Option<NaiveDate>,
    #[field(name = "SYGEHUS_REGION")]
    pub hospital_region: Option<String>,
}
/// Auto-generated deserializer for registry
///
/// This deserializer was generated by the RegistryTrait derive macro
/// and provides methods to deserialize Arrow record batches into Individual models.
pub struct LprAdmRegistryDeserializer {
    inner: std::sync::Arc<dyn crate::registry::trait_deserializer::RegistryDeserializer>,
}
#[automatically_derived]
impl ::core::fmt::Debug for LprAdmRegistryDeserializer {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field1_finish(
            f,
            "LprAdmRegistryDeserializer",
            "inner",
            &&self.inner,
        )
    }
}
impl crate::registry::trait_deserializer::RegistryType for LprAdmRegistry {}
impl LprAdmRegistryDeserializer {
    /// Create a new deserializer for registry
    #[must_use]
    pub fn new() -> Self {
        let schema = Self::create_schema();
        let inner = std::sync::Arc::new(
            crate::registry::trait_deserializer_impl::RegistryDeserializerImpl::new(
                "LPR_ADM",
                "LPR Admission registry",
                schema,
                Some("pnr"),
            ),
        );
        Self { inner }
    }
    /// Create the schema definition for this registry
    fn create_schema() -> crate::schema::RegistrySchema {
        let field_mappings = <[_]>::into_vec(
            ::alloc::boxed::box_new([
                crate::schema::field_def::FieldMapping::new(
                    crate::schema::field_def::FieldDefinition::new(
                        "PNR",
                        "pnr",
                        crate::schema::field_def::FieldType::String,
                        false,
                    ),
                    crate::schema::field_def::mapping::Extractors::string("PNR"),
                    crate::schema::field_def::mapping::ModelSetters::string_setter(|
                        individual,
                        value|
                    {
                        let individual_obj = individual
                            as &mut crate::models::core::Individual;
                        individual_obj.pnr = value;
                    }),
                ),
                crate::schema::field_def::FieldMapping::new(
                    crate::schema::field_def::FieldDefinition::new(
                        "RECNUM",
                        "record_number",
                        crate::schema::field_def::FieldType::String,
                        true,
                    ),
                    crate::schema::field_def::mapping::Extractors::string("RECNUM"),
                    crate::schema::field_def::mapping::ModelSetters::string_setter(|
                        individual,
                        value|
                    {
                        static mut SETTER_COUNT: usize = 0;
                        unsafe {
                            if SETTER_COUNT < 5 {
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "Setting Optional {0} value to Individual: field={1}, value={2:?}\n",
                                            "record_number",
                                            "record_number",
                                            value,
                                        ),
                                    );
                                };
                                SETTER_COUNT += 1;
                            }
                        }
                        let individual_obj = individual
                            as &mut crate::models::core::Individual;
                        let boxed_value: Box<dyn std::any::Any + Send + Sync> = Box::new(
                            Some(value),
                        );
                        individual_obj.set_property("record_number", boxed_value);
                    }),
                ),
                crate::schema::field_def::FieldMapping::new(
                    crate::schema::field_def::FieldDefinition::new(
                        "D_INDDTO",
                        "admission_date",
                        crate::schema::field_def::FieldType::Date,
                        true,
                    ),
                    crate::schema::field_def::mapping::Extractors::date("D_INDDTO"),
                    crate::schema::field_def::mapping::ModelSetters::date_setter(|
                        individual,
                        value|
                    {
                        static mut SETTER_COUNT: usize = 0;
                        unsafe {
                            if SETTER_COUNT < 5 {
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "Setting Optional {0} value to Individual: field={1}, value={2:?}\n",
                                            "admission_date",
                                            "admission_date",
                                            value,
                                        ),
                                    );
                                };
                                SETTER_COUNT += 1;
                            }
                        }
                        let individual_obj = individual
                            as &mut crate::models::core::Individual;
                        let boxed_value: Box<dyn std::any::Any + Send + Sync> = Box::new(
                            Some(value),
                        );
                        individual_obj.set_property("admission_date", boxed_value);
                    }),
                ),
                crate::schema::field_def::FieldMapping::new(
                    crate::schema::field_def::FieldDefinition::new(
                        "SYGEHUS_REGION",
                        "hospital_region",
                        crate::schema::field_def::FieldType::String,
                        true,
                    ),
                    crate::schema::field_def::mapping::Extractors::string(
                        "SYGEHUS_REGION",
                    ),
                    crate::schema::field_def::mapping::ModelSetters::string_setter(|
                        individual,
                        value|
                    {
                        static mut SETTER_COUNT: usize = 0;
                        unsafe {
                            if SETTER_COUNT < 5 {
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "Setting Optional {0} value to Individual: field={1}, value={2:?}\n",
                                            "hospital_region",
                                            "hospital_region",
                                            value,
                                        ),
                                    );
                                };
                                SETTER_COUNT += 1;
                            }
                        }
                        let individual_obj = individual
                            as &mut crate::models::core::Individual;
                        let boxed_value: Box<dyn std::any::Any + Send + Sync> = Box::new(
                            Some(value),
                        );
                        individual_obj.set_property("hospital_region", boxed_value);
                    }),
                ),
            ]),
        );
        crate::schema::create_registry_schema(
            "LPR_ADM",
            "LPR Admission registry",
            field_mappings,
        )
    }
    /// Deserialize a record batch using this deserializer
    pub fn deserialize_batch(
        &self,
        batch: &arrow::record_batch::RecordBatch,
    ) -> crate::error::Result<Vec<LprAdmRegistry>> {
        let result = self
            .inner
            .deserialize_batch(batch)?
            .into_iter()
            .map(|individual| LprAdmRegistry::from(individual))
            .collect();
        Ok(result)
    }
    /// Deserialize a single row from a record batch using this deserializer
    pub fn deserialize_row(
        &self,
        batch: &arrow::record_batch::RecordBatch,
        row: usize,
    ) -> crate::error::Result<Option<LprAdmRegistry>> {
        let result = self
            .inner
            .deserialize_row(batch, row)?
            .map(|individual| LprAdmRegistry::from(individual));
        Ok(result)
    }
}
impl From<crate::models::core::Individual> for LprAdmRegistry {
    fn from(individual: crate::models::core::Individual) -> Self {
        static mut PRINT_COUNT: usize = 0;
        unsafe {
            if PRINT_COUNT < 3 {
                {
                    ::std::io::_print(
                        format_args!("Converting Individual to {0}\n", "LprAdmRegistry"),
                    );
                };
                PRINT_COUNT += 1;
            }
        }
        let mut instance = Self::default();
        instance.pnr = individual.pnr.clone();
        if let Some(props) = individual.properties() {
            if let Some(value) = props.get("record_number") {
                if let Some(string_val) = value.downcast_ref::<Option<String>>() {
                    instance.record_number = string_val.clone();
                }
            }
        }
        if let Some(props) = individual.properties() {
            if let Some(value) = props.get("admission_date") {
                if let Some(date_val) = value.downcast_ref::<Option<chrono::NaiveDate>>()
                {
                    instance.admission_date = *date_val;
                }
            }
        }
        if let Some(props) = individual.properties() {
            if let Some(value) = props.get("hospital_region") {
                if let Some(string_val) = value.downcast_ref::<Option<String>>() {
                    instance.hospital_region = string_val.clone();
                }
            }
        }
        instance
    }
}
impl Default for LprAdmRegistry {
    fn default() -> Self {
        Self {
            pnr: Default::default(),
            record_number: Default::default(),
            admission_date: Default::default(),
            hospital_region: Default::default(),
        }
    }
}
impl Default for LprAdmRegistryDeserializer {
    fn default() -> Self {
        Self::new()
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for LprAdmRegistry {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field4_finish(
            f,
            "LprAdmRegistry",
            "pnr",
            &self.pnr,
            "record_number",
            &self.record_number,
            "admission_date",
            &self.admission_date,
            "hospital_region",
            &&self.hospital_region,
        )
    }
}
/// Registry using RECNUM as ID field
#[registry(
    name = "LPR_DIAG",
    description = "LPR Diagnosis registry",
    id_field = "record_number"
)]
pub struct LprDiagRegistry {
    #[field(name = "RECNUM")]
    pub record_number: Option<String>,
    #[field(name = "C_DIAG")]
    pub diagnosis_code: Option<String>,
    #[field(name = "C_DIAGTYPE")]
    pub diagnosis_type: Option<String>,
}
/// Auto-generated deserializer for registry
///
/// This deserializer was generated by the RegistryTrait derive macro
/// and provides methods to deserialize Arrow record batches into Individual models.
pub struct LprDiagRegistryDeserializer {
    inner: std::sync::Arc<dyn crate::registry::trait_deserializer::RegistryDeserializer>,
}
#[automatically_derived]
impl ::core::fmt::Debug for LprDiagRegistryDeserializer {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field1_finish(
            f,
            "LprDiagRegistryDeserializer",
            "inner",
            &&self.inner,
        )
    }
}
impl crate::registry::trait_deserializer::RegistryType for LprDiagRegistry {}
impl LprDiagRegistryDeserializer {
    /// Create a new deserializer for registry
    #[must_use]
    pub fn new() -> Self {
        let schema = Self::create_schema();
        let inner = std::sync::Arc::new(
            crate::registry::trait_deserializer_impl::RegistryDeserializerImpl::new(
                "LPR_DIAG",
                "LPR Diagnosis registry",
                schema,
                Some("record_number"),
            ),
        );
        Self { inner }
    }
    /// Create the schema definition for this registry
    fn create_schema() -> crate::schema::RegistrySchema {
        let field_mappings = <[_]>::into_vec(
            ::alloc::boxed::box_new([
                crate::schema::field_def::FieldMapping::new(
                    crate::schema::field_def::FieldDefinition::new(
                        "RECNUM",
                        "record_number",
                        crate::schema::field_def::FieldType::String,
                        true,
                    ),
                    crate::schema::field_def::mapping::Extractors::string("RECNUM"),
                    crate::schema::field_def::mapping::ModelSetters::string_setter(|
                        individual,
                        value|
                    {
                        let individual_obj = individual
                            as &mut crate::models::core::Individual;
                        individual_obj.set_property("record_number", Box::new(value));
                    }),
                ),
                crate::schema::field_def::FieldMapping::new(
                    crate::schema::field_def::FieldDefinition::new(
                        "C_DIAG",
                        "diagnosis_code",
                        crate::schema::field_def::FieldType::String,
                        true,
                    ),
                    crate::schema::field_def::mapping::Extractors::string("C_DIAG"),
                    crate::schema::field_def::mapping::ModelSetters::string_setter(|
                        individual,
                        value|
                    {
                        static mut SETTER_COUNT: usize = 0;
                        unsafe {
                            if SETTER_COUNT < 5 {
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "Setting Optional {0} value to Individual: field={1}, value={2:?}\n",
                                            "diagnosis_code",
                                            "diagnosis_code",
                                            value,
                                        ),
                                    );
                                };
                                SETTER_COUNT += 1;
                            }
                        }
                        let individual_obj = individual
                            as &mut crate::models::core::Individual;
                        let boxed_value: Box<dyn std::any::Any + Send + Sync> = Box::new(
                            Some(value),
                        );
                        individual_obj.set_property("diagnosis_code", boxed_value);
                    }),
                ),
                crate::schema::field_def::FieldMapping::new(
                    crate::schema::field_def::FieldDefinition::new(
                        "C_DIAGTYPE",
                        "diagnosis_type",
                        crate::schema::field_def::FieldType::String,
                        true,
                    ),
                    crate::schema::field_def::mapping::Extractors::string("C_DIAGTYPE"),
                    crate::schema::field_def::mapping::ModelSetters::string_setter(|
                        individual,
                        value|
                    {
                        static mut SETTER_COUNT: usize = 0;
                        unsafe {
                            if SETTER_COUNT < 5 {
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "Setting Optional {0} value to Individual: field={1}, value={2:?}\n",
                                            "diagnosis_type",
                                            "diagnosis_type",
                                            value,
                                        ),
                                    );
                                };
                                SETTER_COUNT += 1;
                            }
                        }
                        let individual_obj = individual
                            as &mut crate::models::core::Individual;
                        let boxed_value: Box<dyn std::any::Any + Send + Sync> = Box::new(
                            Some(value),
                        );
                        individual_obj.set_property("diagnosis_type", boxed_value);
                    }),
                ),
            ]),
        );
        crate::schema::create_registry_schema(
            "LPR_DIAG",
            "LPR Diagnosis registry",
            field_mappings,
        )
    }
    /// Deserialize a record batch using this deserializer
    pub fn deserialize_batch(
        &self,
        batch: &arrow::record_batch::RecordBatch,
    ) -> crate::error::Result<Vec<LprDiagRegistry>> {
        let result = self
            .inner
            .deserialize_batch(batch)?
            .into_iter()
            .map(|individual| LprDiagRegistry::from(individual))
            .collect();
        Ok(result)
    }
    /// Deserialize a single row from a record batch using this deserializer
    pub fn deserialize_row(
        &self,
        batch: &arrow::record_batch::RecordBatch,
        row: usize,
    ) -> crate::error::Result<Option<LprDiagRegistry>> {
        let result = self
            .inner
            .deserialize_row(batch, row)?
            .map(|individual| LprDiagRegistry::from(individual));
        Ok(result)
    }
}
impl From<crate::models::core::Individual> for LprDiagRegistry {
    fn from(individual: crate::models::core::Individual) -> Self {
        static mut PRINT_COUNT: usize = 0;
        unsafe {
            if PRINT_COUNT < 3 {
                {
                    ::std::io::_print(
                        format_args!("Converting Individual to {0}\n", "LprDiagRegistry"),
                    );
                };
                PRINT_COUNT += 1;
            }
        }
        let mut instance = Self::default();
        if let Some(props) = individual.properties() {
            if let Some(record_num) = props.get("record_number") {
                if let Some(recnum) = record_num.downcast_ref::<Option<String>>() {
                    instance.record_number = recnum.clone();
                }
            }
        }
        if let Some(props) = individual.properties() {
            if let Some(value) = props.get("diagnosis_code") {
                if let Some(string_val) = value.downcast_ref::<Option<String>>() {
                    instance.diagnosis_code = string_val.clone();
                }
            }
        }
        if let Some(props) = individual.properties() {
            if let Some(value) = props.get("diagnosis_type") {
                if let Some(string_val) = value.downcast_ref::<Option<String>>() {
                    instance.diagnosis_type = string_val.clone();
                }
            }
        }
        instance
    }
}
impl Default for LprDiagRegistry {
    fn default() -> Self {
        Self {
            record_number: Default::default(),
            diagnosis_code: Default::default(),
            diagnosis_type: Default::default(),
        }
    }
}
impl Default for LprDiagRegistryDeserializer {
    fn default() -> Self {
        Self::new()
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for LprDiagRegistry {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field3_finish(
            f,
            "LprDiagRegistry",
            "record_number",
            &self.record_number,
            "diagnosis_code",
            &self.diagnosis_code,
            "diagnosis_type",
            &&self.diagnosis_type,
        )
    }
}
/// Create a mapping from RECNUM to PNR using ADM records
fn create_recnum_to_pnr_mapping(
    adm_records: &[LprAdmRegistry],
) -> HashMap<String, String> {
    let mut mapping = HashMap::new();
    for record in adm_records {
        if let Some(recnum) = &record.record_number {
            if !record.pnr.is_empty() && !recnum.is_empty() {
                mapping.insert(recnum.clone(), record.pnr.clone());
            }
        }
    }
    {
        ::std::io::_print(
            format_args!("Created mapping with {0} RECNUM -> PNR pairs\n", mapping.len()),
        );
    };
    mapping
}
/// Load records from a Parquet file
fn load_records<T: From<par_reader::models::core::Individual>>(
    deserializer: &std::sync::Arc<
        dyn par_reader::registry::trait_deserializer::RegistryDeserializer,
    >,
    batch: &RecordBatch,
) -> Vec<T> {
    match deserializer.deserialize_batch(batch) {
        Ok(individuals) => individuals.into_iter().map(T::from).collect(),
        Err(err) => {
            {
                ::std::io::_eprint(
                    format_args!("Error deserializing batch: {0}\n", err),
                );
            };
            Vec::new()
        }
    }
}
/// Run the test for different ID field types
pub fn run_id_field_test() {
    {
        ::std::io::_print(
            format_args!("Testing different ID field types in registry deserializers\n"),
        );
    };
    let bef_path = Path::new(
        "/Users/tobiaskragholm/generated_data/parquet/bef/202209.parquet",
    );
    {
        ::std::io::_print(format_args!("Loading BEF data from: {0:?}\n", bef_path));
    };
    let lpr_adm_path = Path::new(
        "/Users/tobiaskragholm/generated_data/parquet/lpr_adm/2000.parquet",
    );
    {
        ::std::io::_print(
            format_args!("Loading LPR ADM data from: {0:?}\n", lpr_adm_path),
        );
    };
    let lpr_diag_path = Path::new(
        "/Users/tobiaskragholm/generated_data/parquet/lpr_diag/2000.parquet",
    );
    {
        ::std::io::_print(
            format_args!("Loading LPR DIAG data from: {0:?}\n", lpr_diag_path),
        );
    };
    let bef_deserializer = BefRegistryDeserializer::new();
    let adm_deserializer = LprAdmRegistryDeserializer::new();
    let diag_deserializer = LprDiagRegistryDeserializer::new();
    {
        ::std::io::_print(
            format_args!(
                "BEF deserializer ID field type: {0}\n",
                bef_deserializer.inner.id_field_type(),
            ),
        );
    };
    {
        ::std::io::_print(
            format_args!(
                "LPR ADM deserializer ID field type: {0}\n",
                adm_deserializer.inner.id_field_type(),
            ),
        );
    };
    {
        ::std::io::_print(
            format_args!(
                "LPR DIAG deserializer ID field type: {0}\n",
                diag_deserializer.inner.id_field_type(),
            ),
        );
    };
    match par_reader::loader::read_parquet(bef_path, None, None) {
        Ok(bef_batches) if !bef_batches.is_empty() => {
            {
                ::std::io::_print(
                    format_args!(
                        "Successfully loaded BEF batch with {0} rows\n",
                        bef_batches[0].num_rows(),
                    ),
                );
            };
            let bef_records: Vec<BefRegistry> = bef_deserializer
                .deserialize_batch(&bef_batches[0])
                .unwrap_or_default();
            {
                ::std::io::_print(
                    format_args!("Deserialized {0} BEF records\n", bef_records.len()),
                );
            };
            for (i, record) in bef_records.iter().take(5).enumerate() {
                {
                    ::std::io::_print(
                        format_args!(
                            "[{0}] PNR: {1}, Birth Date: {2:?}, Gender: {3:?}\n",
                            i + 1,
                            record.pnr,
                            record.birth_date,
                            record.gender,
                        ),
                    );
                };
            }
        }
        Ok(_) => {
            {
                ::std::io::_print(format_args!("No BEF batches found\n"));
            };
        }
        Err(err) => {
            {
                ::std::io::_eprint(format_args!("Error loading BEF data: {0}\n", err));
            };
        }
    }
    let adm_records = match par_reader::loader::read_parquet(lpr_adm_path, None, None) {
        Ok(adm_batches) if !adm_batches.is_empty() => {
            {
                ::std::io::_print(
                    format_args!(
                        "Successfully loaded LPR ADM batch with {0} rows\n",
                        adm_batches[0].num_rows(),
                    ),
                );
            };
            let adm_records: Vec<LprAdmRegistry> = adm_deserializer
                .deserialize_batch(&adm_batches[0])
                .unwrap_or_default();
            {
                ::std::io::_print(
                    format_args!("Deserialized {0} LPR ADM records\n", adm_records.len()),
                );
            };
            for (i, record) in adm_records.iter().take(5).enumerate() {
                {
                    ::std::io::_print(
                        format_args!(
                            "[{0}] PNR: {1}, RECNUM: {2:?}, Admission Date: {3:?}\n",
                            i + 1,
                            record.pnr,
                            record.record_number,
                            record.admission_date,
                        ),
                    );
                };
            }
            adm_records
        }
        Ok(_) => {
            {
                ::std::io::_print(format_args!("No LPR ADM batches found\n"));
            };
            Vec::new()
        }
        Err(err) => {
            {
                ::std::io::_eprint(
                    format_args!("Error loading LPR ADM data: {0}\n", err),
                );
            };
            Vec::new()
        }
    };
    let recnum_to_pnr = create_recnum_to_pnr_mapping(&adm_records);
    match par_reader::loader::read_parquet(lpr_diag_path, None, None) {
        Ok(diag_batches) if !diag_batches.is_empty() => {
            {
                ::std::io::_print(
                    format_args!(
                        "Successfully loaded LPR DIAG batch with {0} rows\n",
                        diag_batches[0].num_rows(),
                    ),
                );
            };
            let diag_records: Vec<LprDiagRegistry> = load_records(
                &diag_deserializer.inner,
                &diag_batches[0],
            );
            {
                ::std::io::_print(
                    format_args!(
                        "Deserialized {0} LPR DIAG records\n",
                        diag_records.len(),
                    ),
                );
            };
            for (i, record) in diag_records.iter().take(5).enumerate() {
                let pnr = record
                    .record_number
                    .as_ref()
                    .and_then(|recnum| recnum_to_pnr.get(recnum))
                    .cloned()
                    .unwrap_or_else(|| "Not found".to_string());
                {
                    ::std::io::_print(
                        format_args!(
                            "[{0}] RECNUM: {1:?}, Diagnosis: {2:?}, Type: {3:?}, PNR: {4}\n",
                            i + 1,
                            record.record_number,
                            record.diagnosis_code,
                            record.diagnosis_type,
                            pnr,
                        ),
                    );
                };
            }
            let matched_count = diag_records
                .iter()
                .filter(|r| {
                    r.record_number
                        .as_ref()
                        .and_then(|recnum| recnum_to_pnr.get(recnum))
                        .is_some()
                })
                .count();
            {
                ::std::io::_print(
                    format_args!(
                        "Found PNR matches for {0}/{1} DIAG records\n",
                        matched_count,
                        diag_records.len(),
                    ),
                );
            };
        }
        Ok(_) => {
            {
                ::std::io::_print(format_args!("No LPR DIAG batches found\n"));
            };
        }
        Err(err) => {
            {
                ::std::io::_eprint(
                    format_args!("Error loading LPR DIAG data: {0}\n", err),
                );
            };
        }
    }
}
pub fn main() {
    run_id_field_test();
}
